EmacsKeys.

 --== BUILD INSTRUCTIONS ==--

1. First you need to build the QtCreator itself from the source code. It should
   be trivial, something like this:

      git clone git://gitorious.org/qt-creator/qt-creator.git
      mkdir build && cd build
      qmake ../qt-creator/qtcreator.pro
      make

   At the end you'll have two dirs: 'qt-creator' and 'build'. One contains the
   source code, the other contains the binaries and libraries.

2. Then you need to build the plugin itself. There is an official guide of some
   sort here: http://doc.qt.digia.com/qtcreator-extending/first-plugin.html.
   But it covers more than an average user needs. The main part is that you need
   to set two environment variables:

    * QTC_SOURCE - points to 'qt-creator' dir from step 1.
    * QTC_BUILD - points to 'build' dir from step 1.

   And after that invoking qmake and make should be enough to build the
   plugin. Something like that:

      git clone git://github.com/nsf/emacskeys
      mkdir build && cd build
      qmake ..
      make

   At the end you'll get your plugin installed into the 'build' dir from step 1.
   It should be somewhere in: 'build/lib/qtcreator/plugins/nsf'.

3. ...

4. PROFIT!

 --== DESCRIPTION ==--

A very simple QtCreator plugin, it adds a bunch of emacs-oriented actions. You
can bind appropriate keys manually using the main keyboard shortcuts menu.

Supported actions (copy & paste from the code):

	void deleteCharacter();       // C-d
	void killWord();              // M-d
	void killLine();              // C-k

	void gotoFileStart();         // M-<
	void gotoFileEnd();           // M->
	void gotoLineStart();         // C-a
	void gotoLineEnd();           // C-e
	void gotoNextLine();          // C-n
	void gotoPreviousLine();      // C-p
	void gotoNextCharacter();     // C-f
	void gotoPreviousCharacter(); // C-b
	void gotoNextWord();          // M-f
	void gotoPreviousWord();      // M-b

	void mark();                  // C-SPC
	void exchangeCursorAndMark(); // C-x C-x
	void copy();                  // M-w
	void cut();                   // C-w
	void yank();                  // C-y

	void scrollHalfDown();        // C-v
	void scrollHalfUp();          // M-v

Notes:

 1. No kill ring, copy/cut/yank just uses ordinary Qt clipboard.
 2. Scrolling scrolls half of the screen instead of the full screen as in
    default emacs. It seems like a better idea. Also unlike default
    QPlainTextEdit scrolling, this scrolling operations keep cursor within
    visible area, pulling it down or up as necessary, it's a critical part of
    keyboard-based navigation.

 --== TODO ==--

 1. Closing code assist popup menu when moving left/right (or other movement
    keys). At the moment it's not an easy thing to do. Code assist code is only
    aware of a bunch of hardcoded keys and it checks if the cursor moved out of
    the completion point after one of these keys were pressed. Perhaps it's
    possible to simply force closing of a popup window by invoking
    BaseTextEditorWidget's abortAssist slot at the right moment.

 2. At the moment when you undo kill line, cursor ends up being at the end of
    the line, perhaps there is a way to record the history in such way that it
    ends up being in the original location instead.

 3. Don't know about others, but I use C-j to do the "insert newline"
    action. The problem with it is that it needs to do automatic indentation. As
    far as I've seen this functionality exists as a part of the texteditor
    plugin as part of the BaseTextDocument class. Adding a plugin dependancy is
    always a question to think about. So far I was managed to stay within
    QPlainTextEdit range. Seems like it's inevitable though (see item #1).